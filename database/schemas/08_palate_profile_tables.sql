-- Palate Profile Algorithm Database Schema\n-- Advanced tables for patent-pending palate profiling system\n\n-- Table for storing detailed user palate profiles\nCREATE TABLE IF NOT EXISTS public.user_palate_profiles (\n    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n    user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL UNIQUE,\n    \n    -- 11-dimensional palate vector\n    palate_vector JSONB NOT NULL DEFAULT '{\n        \"sweet\": 5, \"salty\": 5, \"sour\": 5, \"bitter\": 5, \"umami\": 5,\n        \"spicy\": 5, \"crunchy\": 5, \"creamy\": 5, \"chewy\": 5, \"hot\": 5, \"cold\": 5\n    }'::jsonb,\n    \n    -- 11x5 emotional preference matrix (taste dimensions x emotional responses)\n    emotional_preference_matrix DECIMAL[][] DEFAULT ARRAY[\n        ARRAY[0.5, 0.5, 0.5, 0.5, 0.5], -- sweet -> [satisfaction, excitement, comfort, surprise, nostalgia]\n        ARRAY[0.5, 0.5, 0.5, 0.5, 0.5], -- salty\n        ARRAY[0.5, 0.5, 0.5, 0.5, 0.5], -- sour\n        ARRAY[0.5, 0.5, 0.5, 0.5, 0.5], -- bitter\n        ARRAY[0.5, 0.5, 0.5, 0.5, 0.5], -- umami\n        ARRAY[0.5, 0.5, 0.5, 0.5, 0.5], -- spicy\n        ARRAY[0.5, 0.5, 0.5, 0.5, 0.5], -- crunchy\n        ARRAY[0.5, 0.5, 0.5, 0.5, 0.5], -- creamy\n        ARRAY[0.5, 0.5, 0.5, 0.5, 0.5], -- chewy\n        ARRAY[0.5, 0.5, 0.5, 0.5, 0.5], -- hot\n        ARRAY[0.5, 0.5, 0.5, 0.5, 0.5]  -- cold\n    ],\n    \n    -- Context weights for different situations\n    context_weights JSONB DEFAULT '{}'::jsonb,\n    \n    -- Evolution history tracking taste changes\n    evolution_history JSONB DEFAULT '[]'::jsonb,\n    \n    -- Profile metadata\n    confidence_score DECIMAL(5,2) DEFAULT 0.0 CHECK (confidence_score >= 0 AND confidence_score <= 100),\n    profile_maturity TEXT DEFAULT 'novice' CHECK (profile_maturity IN ('novice', 'developing', 'established', 'expert')),\n    total_experiences INTEGER DEFAULT 0,\n    \n    -- Timestamps\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,\n    last_updated TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL\n);\n\n-- Table for storing detailed food experiences with emotional responses\nCREATE TABLE IF NOT EXISTS public.food_experiences_detailed (\n    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n    user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,\n    \n    -- Food item details\n    food_item TEXT NOT NULL,\n    cuisine_type TEXT,\n    restaurant_id UUID REFERENCES public.restaurants(id) ON DELETE SET NULL,\n    \n    -- Palate profile for this specific experience\n    palate_profile JSONB NOT NULL,\n    \n    -- Emotional response data\n    emotional_response JSONB NOT NULL DEFAULT '{\n        \"satisfaction\": 5, \"excitement\": 5, \"comfort\": 5, \n        \"surprise\": 5, \"nostalgia\": 5, \"overall_rating\": 5, \n        \"emotional_intensity\": 5\n    }'::jsonb,\n    \n    -- Contextual factors\n    context JSONB NOT NULL DEFAULT '{\n        \"time_of_day\": \"unknown\", \"mood_before\": \"neutral\", \n        \"social_setting\": \"alone\", \"weather\": \"unknown\", \n        \"location_type\": \"unknown\"\n    }'::jsonb,\n    \n    -- User confidence in their rating\n    confidence DECIMAL(3,2) DEFAULT 0.8 CHECK (confidence >= 0 AND confidence <= 1),\n    \n    -- Timestamps\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL\n);\n\n-- Table for caching user similarity calculations\nCREATE TABLE IF NOT EXISTS public.user_similarity_cache (\n    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n    user_a UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,\n    user_b UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,\n    \n    -- Similarity metrics\n    similarity_score DECIMAL(5,4) NOT NULL CHECK (similarity_score >= 0 AND similarity_score <= 1),\n    taste_alignment DECIMAL(5,4) NOT NULL CHECK (taste_alignment >= 0 AND taste_alignment <= 1),\n    emotional_alignment DECIMAL(5,4) NOT NULL CHECK (emotional_alignment >= 0 AND emotional_alignment <= 1),\n    context_alignment DECIMAL(5,4) NOT NULL CHECK (context_alignment >= 0 AND context_alignment <= 1),\n    confidence DECIMAL(5,4) NOT NULL CHECK (confidence >= 0 AND confidence <= 1),\n    \n    -- Cache metadata\n    algorithm_version TEXT DEFAULT 'v1.0' NOT NULL,\n    calculated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,\n    expires_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now() + interval '7 days') NOT NULL,\n    \n    -- Ensure no duplicate pairs\n    UNIQUE(user_a, user_b),\n    CHECK (user_a != user_b)\n);\n\n-- Table for storing recommendation scores and explanations\nCREATE TABLE IF NOT EXISTS public.recommendation_scores (\n    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n    user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,\n    \n    -- Item being recommended (could be restaurant or food item)\n    item_type TEXT NOT NULL CHECK (item_type IN ('restaurant', 'food_item', 'experience')),\n    item_id UUID NOT NULL,\n    \n    -- Recommendation scores\n    total_score DECIMAL(5,4) NOT NULL CHECK (total_score >= 0 AND total_score <= 1),\n    taste_score DECIMAL(5,4) NOT NULL CHECK (taste_score >= 0 AND taste_score <= 1),\n    emotional_score DECIMAL(5,4) NOT NULL CHECK (emotional_score >= 0 AND emotional_score <= 1),\n    context_score DECIMAL(5,4) NOT NULL CHECK (context_score >= 0 AND context_score <= 1),\n    collaborative_score DECIMAL(5,4) NOT NULL CHECK (collaborative_score >= 0 AND collaborative_score <= 1),\n    novelty_score DECIMAL(5,4) NOT NULL CHECK (novelty_score >= 0 AND novelty_score <= 1),\n    \n    -- Recommendation metadata\n    confidence DECIMAL(5,4) NOT NULL CHECK (confidence >= 0 AND confidence <= 1),\n    reasoning TEXT,\n    context_hash TEXT, -- Hash of the context used for this recommendation\n    \n    -- Algorithm metadata\n    algorithm_version TEXT DEFAULT 'palate_profile_v1.0' NOT NULL,\n    generated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,\n    expires_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now() + interval '24 hours') NOT NULL\n);\n\n-- Table for tracking algorithm performance metrics\nCREATE TABLE IF NOT EXISTS public.algorithm_performance_metrics (\n    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n    \n    -- Algorithm identification\n    algorithm_name TEXT NOT NULL,\n    algorithm_version TEXT NOT NULL,\n    \n    -- Performance metrics\n    metric_type TEXT NOT NULL CHECK (metric_type IN (\n        'accuracy', 'mae', 'rmse', 'precision', 'recall', \n        'similarity_accuracy', 'recommendation_acceptance_rate',\n        'diversity_score', 'novelty_score', 'processing_time'\n    )),\n    metric_value DECIMAL(10,6) NOT NULL,\n    \n    -- Test metadata\n    test_dataset_size INTEGER,\n    test_conditions JSONB,\n    \n    -- Timestamps\n    measured_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL\n);\n\n-- Table for A/B testing algorithm variations\nCREATE TABLE IF NOT EXISTS public.algorithm_ab_tests (\n    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n    \n    -- Test identification\n    test_name TEXT NOT NULL,\n    test_description TEXT,\n    \n    -- Algorithm variants\n    control_algorithm TEXT NOT NULL,\n    test_algorithm TEXT NOT NULL,\n    \n    -- Test parameters\n    traffic_split DECIMAL(3,2) DEFAULT 0.5 CHECK (traffic_split >= 0 AND traffic_split <= 1),\n    test_duration_days INTEGER DEFAULT 7,\n    \n    -- Success criteria\n    success_metric TEXT NOT NULL,\n    success_threshold DECIMAL(5,4) NOT NULL,\n    \n    -- Test status\n    status TEXT DEFAULT 'planned' CHECK (status IN ('planned', 'running', 'completed', 'stopped')),\n    \n    -- Timestamps\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,\n    started_at TIMESTAMP WITH TIME ZONE,\n    ended_at TIMESTAMP WITH TIME ZONE\n);\n\n-- Table for storing A/B test results\nCREATE TABLE IF NOT EXISTS public.algorithm_ab_test_results (\n    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n    test_id UUID REFERENCES public.algorithm_ab_tests(id) ON DELETE CASCADE NOT NULL,\n    user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,\n    \n    -- Which variant the user was assigned to\n    variant TEXT NOT NULL CHECK (variant IN ('control', 'test')),\n    \n    -- Outcome metrics\n    metric_name TEXT NOT NULL,\n    metric_value DECIMAL(10,6) NOT NULL,\n    \n    -- Context\n    context JSONB,\n    \n    -- Timestamp\n    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL\n);\n\n-- Indexes for performance optimization\nCREATE INDEX IF NOT EXISTS idx_user_palate_profiles_user_id ON public.user_palate_profiles(user_id);\nCREATE INDEX IF NOT EXISTS idx_user_palate_profiles_maturity ON public.user_palate_profiles(profile_maturity);\nCREATE INDEX IF NOT EXISTS idx_user_palate_profiles_updated ON public.user_palate_profiles(last_updated);\n\nCREATE INDEX IF NOT EXISTS idx_food_experiences_detailed_user_id ON public.food_experiences_detailed(user_id);\nCREATE INDEX IF NOT EXISTS idx_food_experiences_detailed_cuisine ON public.food_experiences_detailed(cuisine_type);\nCREATE INDEX IF NOT EXISTS idx_food_experiences_detailed_created ON public.food_experiences_detailed(created_at);\nCREATE INDEX IF NOT EXISTS idx_food_experiences_detailed_restaurant ON public.food_experiences_detailed(restaurant_id);\n\nCREATE INDEX IF NOT EXISTS idx_user_similarity_cache_user_a ON public.user_similarity_cache(user_a);\nCREATE INDEX IF NOT EXISTS idx_user_similarity_cache_user_b ON public.user_similarity_cache(user_b);\nCREATE INDEX IF NOT EXISTS idx_user_similarity_cache_similarity ON public.user_similarity_cache(similarity_score DESC);\nCREATE INDEX IF NOT EXISTS idx_user_similarity_cache_expires ON public.user_similarity_cache(expires_at);\n\nCREATE INDEX IF NOT EXISTS idx_recommendation_scores_user_id ON public.recommendation_scores(user_id);\nCREATE INDEX IF NOT EXISTS idx_recommendation_scores_item ON public.recommendation_scores(item_type, item_id);\nCREATE INDEX IF NOT EXISTS idx_recommendation_scores_total ON public.recommendation_scores(total_score DESC);\nCREATE INDEX IF NOT EXISTS idx_recommendation_scores_expires ON public.recommendation_scores(expires_at);\n\nCREATE INDEX IF NOT EXISTS idx_algorithm_performance_algorithm ON public.algorithm_performance_metrics(algorithm_name, algorithm_version);\nCREATE INDEX IF NOT EXISTS idx_algorithm_performance_metric ON public.algorithm_performance_metrics(metric_type);\nCREATE INDEX IF NOT EXISTS idx_algorithm_performance_measured ON public.algorithm_performance_metrics(measured_at);\n\n-- Row Level Security\nALTER TABLE public.user_palate_profiles ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.food_experiences_detailed ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.user_similarity_cache ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.recommendation_scores ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.algorithm_performance_metrics ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.algorithm_ab_tests ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.algorithm_ab_test_results ENABLE ROW LEVEL SECURITY;\n\n-- RLS Policies for user_palate_profiles\nCREATE POLICY \"Users can view their own palate profile\" ON public.user_palate_profiles\n    FOR SELECT USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update their own palate profile\" ON public.user_palate_profiles\n    FOR ALL USING (auth.uid() = user_id);\n\n-- RLS Policies for food_experiences_detailed\nCREATE POLICY \"Users can view their own food experiences\" ON public.food_experiences_detailed\n    FOR SELECT USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can insert their own food experiences\" ON public.food_experiences_detailed\n    FOR INSERT WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update their own food experiences\" ON public.food_experiences_detailed\n    FOR UPDATE USING (auth.uid() = user_id);\n\n-- RLS Policies for user_similarity_cache (read-only for users)\nCREATE POLICY \"Users can view similarity data involving them\" ON public.user_similarity_cache\n    FOR SELECT USING (auth.uid() = user_a OR auth.uid() = user_b);\n\n-- RLS Policies for recommendation_scores\nCREATE POLICY \"Users can view their own recommendation scores\" ON public.recommendation_scores\n    FOR SELECT USING (auth.uid() = user_id);\n\n-- Functions for algorithm operations\n\n-- Function to update palate profile with automatic timestamp\nCREATE OR REPLACE FUNCTION update_palate_profile_timestamp()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.last_updated = timezone('utc'::text, now());\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_update_palate_profile_timestamp \n    BEFORE UPDATE ON public.user_palate_profiles\n    FOR EACH ROW EXECUTE FUNCTION update_palate_profile_timestamp();\n\n-- Function to clean expired similarity cache\nCREATE OR REPLACE FUNCTION clean_expired_similarity_cache()\nRETURNS INTEGER AS $$\nDECLARE\n    deleted_count INTEGER;\nBEGIN\n    DELETE FROM public.user_similarity_cache \n    WHERE expires_at < timezone('utc'::text, now());\n    \n    GET DIAGNOSTICS deleted_count = ROW_COUNT;\n    RETURN deleted_count;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to clean expired recommendation scores\nCREATE OR REPLACE FUNCTION clean_expired_recommendation_scores()\nRETURNS INTEGER AS $$\nDECLARE\n    deleted_count INTEGER;\nBEGIN\n    DELETE FROM public.recommendation_scores \n    WHERE expires_at < timezone('utc'::text, now());\n    \n    GET DIAGNOSTICS deleted_count = ROW_COUNT;\n    RETURN deleted_count;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to get cached similar users for a target user\nCREATE OR REPLACE FUNCTION get_cached_similar_users(\n    target_user_id UUID,\n    similarity_threshold DECIMAL DEFAULT 0.8\n)\nRETURNS TABLE (\n    user_a UUID,\n    user_b UUID,\n    similarity_score DECIMAL,\n    taste_alignment DECIMAL,\n    emotional_alignment DECIMAL,\n    context_alignment DECIMAL,\n    confidence DECIMAL\n) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        usc.user_a,\n        usc.user_b,\n        usc.similarity_score,\n        usc.taste_alignment,\n        usc.emotional_alignment,\n        usc.context_alignment,\n        usc.confidence\n    FROM public.user_similarity_cache usc\n    WHERE (usc.user_a = target_user_id OR usc.user_b = target_user_id)\n      AND usc.similarity_score >= similarity_threshold\n      AND usc.expires_at > timezone('utc'::text, now())\n    ORDER BY usc.similarity_score DESC;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to calculate palate vector similarity (cosine similarity)\nCREATE OR REPLACE FUNCTION calculate_palate_similarity(\n    vector_a JSONB,\n    vector_b JSONB\n)\nRETURNS DECIMAL AS $$\nDECLARE\n    dot_product DECIMAL := 0;\n    magnitude_a DECIMAL := 0;\n    magnitude_b DECIMAL := 0;\n    dimension TEXT;\n    value_a DECIMAL;\n    value_b DECIMAL;\nBEGIN\n    -- Calculate dot product and magnitudes\n    FOR dimension IN SELECT jsonb_object_keys(vector_a)\n    LOOP\n        value_a := (vector_a->>dimension)::DECIMAL;\n        value_b := (vector_b->>dimension)::DECIMAL;\n        \n        dot_product := dot_product + (value_a * value_b);\n        magnitude_a := magnitude_a + (value_a * value_a);\n        magnitude_b := magnitude_b + (value_b * value_b);\n    END LOOP;\n    \n    -- Calculate cosine similarity\n    IF magnitude_a = 0 OR magnitude_b = 0 THEN\n        RETURN 0;\n    END IF;\n    \n    RETURN dot_product / (sqrt(magnitude_a) * sqrt(magnitude_b));\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to record algorithm performance metric\nCREATE OR REPLACE FUNCTION record_algorithm_performance(\n    p_algorithm_name TEXT,\n    p_algorithm_version TEXT,\n    p_metric_type TEXT,\n    p_metric_value DECIMAL,\n    p_test_dataset_size INTEGER DEFAULT NULL,\n    p_test_conditions JSONB DEFAULT NULL\n)\nRETURNS UUID AS $$\nDECLARE\n    metric_id UUID;\nBEGIN\n    INSERT INTO public.algorithm_performance_metrics (\n        algorithm_name,\n        algorithm_version,\n        metric_type,\n        metric_value,\n        test_dataset_size,\n        test_conditions\n    )\n    VALUES (\n        p_algorithm_name,\n        p_algorithm_version,\n        p_metric_type,\n        p_metric_value,\n        p_test_dataset_size,\n        p_test_conditions\n    )\n    RETURNING id INTO metric_id;\n    \n    RETURN metric_id;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to get algorithm performance summary\nCREATE OR REPLACE FUNCTION get_algorithm_performance_summary(\n    p_algorithm_name TEXT,\n    p_algorithm_version TEXT DEFAULT NULL,\n    p_days_back INTEGER DEFAULT 30\n)\nRETURNS TABLE (\n    metric_type TEXT,\n    avg_value DECIMAL,\n    min_value DECIMAL,\n    max_value DECIMAL,\n    latest_value DECIMAL,\n    measurement_count BIGINT\n) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        apm.metric_type,\n        AVG(apm.metric_value) as avg_value,\n        MIN(apm.metric_value) as min_value,\n        MAX(apm.metric_value) as max_value,\n        (\n            SELECT apm2.metric_value \n            FROM public.algorithm_performance_metrics apm2 \n            WHERE apm2.algorithm_name = apm.algorithm_name \n              AND (p_algorithm_version IS NULL OR apm2.algorithm_version = p_algorithm_version)\n              AND apm2.metric_type = apm.metric_type\n            ORDER BY apm2.measured_at DESC \n            LIMIT 1\n        ) as latest_value,\n        COUNT(*) as measurement_count\n    FROM public.algorithm_performance_metrics apm\n    WHERE apm.algorithm_name = p_algorithm_name\n      AND (p_algorithm_version IS NULL OR apm.algorithm_version = p_algorithm_version)\n      AND apm.measured_at >= timezone('utc'::text, now() - (p_days_back || ' days')::interval)\n    GROUP BY apm.metric_type\n    ORDER BY apm.metric_type;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Comments for documentation\nCOMMENT ON TABLE public.user_palate_profiles IS 'Stores comprehensive palate profiles using patent-pending 11-dimensional taste vectors and emotional preference matrices';\nCOMMENT ON TABLE public.food_experiences_detailed IS 'Detailed food experiences with palate profiles and emotional responses for machine learning';\nCOMMENT ON TABLE public.user_similarity_cache IS 'Cached user similarity calculations for 90%+ accuracy matching system';\nCOMMENT ON TABLE public.recommendation_scores IS 'Recommendation scores with detailed breakdown and explanations';\nCOMMENT ON TABLE public.algorithm_performance_metrics IS 'Performance tracking for algorithm validation and optimization';\nCOMMENT ON TABLE public.algorithm_ab_tests IS 'A/B testing framework for algorithm improvements';\n\nCOMMENT ON COLUMN public.user_palate_profiles.palate_vector IS '11-dimensional taste preference vector: sweet, salty, sour, bitter, umami, spicy, crunchy, creamy, chewy, hot, cold';\nCOMMENT ON COLUMN public.user_palate_profiles.emotional_preference_matrix IS '11x5 matrix mapping taste dimensions to emotional responses (satisfaction, excitement, comfort, surprise, nostalgia)';\nCOMMENT ON COLUMN public.user_palate_profiles.profile_maturity IS 'User profile maturity level affecting learning rate: novice, developing, established, expert';\n\nCOMMENT ON FUNCTION calculate_palate_similarity IS 'Calculates cosine similarity between two 11-dimensional palate vectors';\nCOMMENT ON FUNCTION get_cached_similar_users IS 'Retrieves cached similar users with 90%+ similarity threshold';\nCOMMENT ON FUNCTION record_algorithm_performance IS 'Records performance metrics for algorithm validation and patent claims';\n"